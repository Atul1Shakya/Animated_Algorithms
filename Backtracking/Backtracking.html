<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
    integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous" />
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"
    integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-Fy6S3B9q64WdZWQUiU+q4/2Lc9npb8tCaSX9FK7E8HnRr0Jz8D6OP9dO5Vg3Q9ct"
    crossorigin="anonymous"></script>
  <!-- font- lato -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap"
    rel="stylesheet">
  <title>Template</title>
  <link rel="stylesheet" href="css/style.css" />
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-light" style="background-color: rgb(226, 76, 113)">
    <a class="navbar-brand" href="#">
      <img src="resource/nav-logo.png" width="180" alt="" />
    </a>
    <button class="navbar-toggler me-auto" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <h4 class="nav-item disabled">\N-Queens Problem</h4>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="nav-link" href="bubble_sort.html">Backtracking</a>
        </li>
       
        <!--li class="nav-item">
                    <a class="nav-link disabled">Disabled</a>
                </li -->
      </ul>
      <form class="form-inline my-2 my-lg-0">
        <input class="form-control mr-sm-2" type="search" placeholder="Search Algorithms..." aria-label="Search" />
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">
          GO
        </button>

        <!-- ANOTHER OPTION 
            <button class="btn btn-outline-light btn-dark my-2 my-sm-0" type="submit">GO</button> -->
      </form>
    </div>
  </nav>

  <!-- content -->

  <div class="content">
    <h1>Backtracking</h1>
    <p>Backtracking is a problem-solving technique in computer science and mathematics where a solution is found through a trial-and-error approach. It is a type of brute-force search algorithm that explores all possible solutions by systematically trying out different options until the correct one is found. </p>

    <p>Backtracking involves building a solution incrementally, one step at a time, and then undoing any incorrect steps that lead to a dead-end. This means that backtracking algorithms are often used for solving problems with constraints, such as finding the best move in a game or finding the shortest path in a maze.</p>


    <h3>
      How Backtracking Works?
    </h3>
    <ol>
     <li>In a backtracking algorithm, the search starts with an initial state and then explores all possible paths that lead to a solution. At each step, the algorithm makes a decision and then moves to the next state. If the algorithm reaches a dead-end, it backtracks to the previous state and tries another path.</li>

     <li>The key to a successful backtracking algorithm is to identify the conditions that lead to a dead-end and to quickly prune those paths that are unlikely to lead to a solution. By doing so, the algorithm can focus its search on the most promising paths and quickly find a solution.</li>
    </ol>


    <h3>
      Complexity Analysis of Selection sort:
    </h3>
    <h5>Time Complexity:</h5>
    <ul>
      <li><b>Best Case:</b> <i>Determining the "best" time complexity for a backtracking algorithm depends on the specific problem being solved and the constraints of the problem. In some cases, it may be possible to find an optimal solution with a relatively low time complexity, while in other cases the best possible solution may still have a high time complexity.</i></li>
     <li><b>Worst Case:</b> <i>In general, the best approach to reduce the time complexity of a backtracking algorithm is to apply various pruning techniques to eliminate as many dead-end paths as possible. This can include heuristics to prioritize the most promising paths, early termination conditions to stop the algorithm as soon as a solution is found, and other optimizations such as memoization to avoid redundant computations.</li>
      
    </ul>
    <h5 class="spacecomplexity">Auxiliary Space:</h5>
    <i>O(wh)</i> The space complexity of a backtracking algorithm depends on the maximum depth of the recursion tree and the amount of memory required to store intermediate results. In the animation code I provided, the space complexity of the backtracking algorithm is O(wh), where w is the width of the grid and h is the height of the grid. This is because the maximum depth of the recursion tree is wh, and at each level of the tree, the algorithm needs to store the current position and the path taken so far, which requires O(1) space.


    <h3>Pseudo Code</h3>

   <ul>
    <li>
      backtrack(state):
  <br>  if is_solution(state):
    <br>    return state
       <br>             else:
     <br>   for each candidate in candidates(state):
        <br>   if is_valid(candidate, state):
           <br>     add candidate to state
           <br>     result = backtrack(state)
           <br>     if result is not None:
           <br>         return result
             <br>   remove candidate from state
        return None

    </li>
   </ul>

   <h4>What is N-Queen problem ?</h4>

   <p>The N-Queens problem is a classic problem in computer science and combinatorial optimization. The problem is to place N chess queens on an N x N chessboard so that no two queens threaten each other. This means that no two queens can be placed in the same row, column, or diagonal.</p>

   <p>The problem was first posed in the mid-1800s and has since been extensively studied and used as a benchmark for testing various search and optimization algorithms. The N-Queens problem has many interesting properties and variations, and it is often used as a teaching example to illustrate backtracking algorithms, constraint satisfaction, and other concepts in computer science and mathematics.

   </p>

   <p>The N-Queens problem can be solved using a backtracking algorithm by generating all possible placements of queens on the board and checking whether each placement is valid. The backtracking algorithm explores the solution space recursively, eliminating invalid placements and continuing the search until a valid solution is found or all possible placements have been explored.</p>


   <h3>Here's the animation to show backtracking via N-queen problem !</h3>

   <video width="1000" height="900" autoplay>
    <source src="backtracking video.mp4" type="video/mp4">
    
  Your browser does not support the video tag.
  </video>


        <!-- form for animations -->





</body>

</html>